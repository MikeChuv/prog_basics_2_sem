# Лабораторная работа № 8

### Постановка задачи.

Разработать программу для сортировки элементов динамического массива, используя сортировку обменами, сортировку выбором, сортировку включением и быструю сортировку. \
Реализовать в одной программе возможность обработки массивов, содержащих данные двух типов:
- целый
- строковый

Определить как меняется время сортировки массива в завимости от следующих параметров:
- объём исходных данных;
- упорядоченность исходных данных (данные расположены в требуемом порядке, данные расположены в обратном порядке, данные расположены в случайном порядке);
- метод сортировки;
- тип элементов массива. 

### Таблица данных
**Для основной программы**
| **Класс**          | **Имя**       | **Смысл**                           | **Тип**         |
|--------------------|---------------|-------------------------------------|-----------------|
| Пром.              | start, finish | время запуска и остановки измерения | System.DateTime |
| Пром.              | ts            | время работы алгоритма              | System.TimeSpan |
| Пром.              | testFileArray | массив с именами входных файлов     | строковый       |
| Пром.              | sortAlgArray  | массив с именами функций сортировки | строковый       |
| Входные и выходные | thisArray     | обрабатываемый массив               | arrayElement    |
| Пром.              | foutName      | имя выходного файла                 | строковый       |

**Для алгоритмов сортировки**
| **Класс**          | **Имя**     | **Смысл**            | **Тип**      | **Структура**                |
|--------------------|-------------|----------------------|--------------|------------------------------|
| Пром.              | i,j         | индексы элементов    | цел.         | прост. перем.                |
| Пром.              | key, pivot  | опорные элменты      | arrayElement | зависит от типа arrayElement |
| Пром.              | tmp         | дублер               | arrayElement | зависит от типа arrayElement |
| Пром.              | imin        | индекс минимального  | цел.         | прост. перем.                |
| Пром.              | sorted      | флаг упорядоченности | лог.         | прост. перем.                |
| Входные и выходные | x           | сортируемый массив   | arrayElement | зависит от типа arrayElement |
| Входные            | start, stop | границы              | цел.         | прост. перем.                |


### Входная форма
\< количество элементов > \
\< числа > (могут восприниматься как строки)
### Выходная форма
Отсортированные числа или строки
### Тестовые примеры
**Для целого типа**
|               | bubbleSort | bubbleSortFlag | selectionSort | insertionSort | quickSort |
|---------------|------------|----------------|---------------|---------------|-----------|
| Forvard1000   | 00.002     | 00.001         | 00.001        | 00.001        | 00.000    |
| Forvard5000   | 00.033     | 00.000         | 00.033        | 00.000        | 00.000    |
| Forvard10000  | 00.132     | 00.000         | 00.133        | 00.000        | 00.001    |
| Forvard20000  | 00.522     | 00.000         | 00.524        | 00.000        | 00.000    |
| Backward1000  | 00.004     | 00.005         | 00.001        | 00.002        | 00.000    |
| Backward5000  | 00.085     | 00.126         | 00.033        | 00.054        | 00.001    |
| Backward10000 | 00.356     | 00.504         | 00.133        | 00.261        | 00.000    |
| Backward20000 | 01.413     | 01.999         | 00.539        | 00.885        | 00.000    |
| Random1000    | 00.004     | 00.006         | 00.002        | 00.002        | 00.000    |
| Random5000    | 00.087     | 00.125         | 00.032        | 00.028        | 00.000    |
| Random10000   | 00.363     | 00.515         | 00.135        | 00.120        | 00.000    |
| Random20000   | 01.440     | 02.043         | 00.562        | 00.426        | 00.002    |


**Для строкового типа**
|               | bubbleSort | bubbleSortFlag | selectionSort | insertionSort | quickSort |
|---------------|------------|----------------|---------------|---------------|-----------|
| Forvard1000   | 00.007     | 00.002         | 00.004        | 00.001        | 00.001    |
| Forvard5000   | 00.144     | 00.059         | 00.089        | 00.031        | 00.002    |
| Forvard10000  | 00.600     | 00.118         | 00.353        | 00.048        | 00.002    |
| Forvard20000  | 02.498     | 02.432         | 01.575        | 00.995        | 00.005    |
| Backward1000  | 00.006     | 00.011         | 00.004        | 00.004        | 00.000    |
| Backward5000  | 00.169     | 00.319         | 00.120        | 00.090        | 00.001    |
| Backward10000 | 00.693     | 01.219         | 00.447        | 00.446        | 00.002    |
| Backward20000 | 02.731     | 05.012         | 01.708        | 01.098        | 00.005    |
| Random1000    | 00.009     | 00.016         | 00.004        | 00.003        | 00.000    |
| Random5000    | 00.248     | 00.438         | 00.134        | 00.064        | 00.002    |
| Random10000   | 00.969     | 01.783         | 00.420        | 00.267        | 00.003    |
| Random20000   | 04.029     | 07.796         | 02.650        | 01.184        | 00.007    |
### Метод

**bubbleSort**  \
С помощью двух вложенных циклов сравнивается каждый элемент со следующим. В случае если элемент с меньшим индексом больше, чем элемент с большим – они меняются местами. \
**bubbleSortFlag** \
Аналогично обычной сортировке пузырьком, только при полной упорядоченности данных происходит только один проход по массиву. \
**selectionSort** \
На каждом шаге находится минимальный из элементов, индексы которых больше индекса текущего элемента. Этот минимум ставится на место текущего элемента. \
**insertionSort** \
Пока предыдуший элемент больше, чем текущий (опорный), сдвигаем опорный влево. \
**quickSort** \
Фиксируется опорный элемент(в общем случае любой), то есть происходит разделение массива на две части - до опорного и после. Затем ищется первый элемент больше опорного с начала и первый  элемент меньше опорного с конца и они меняются. Повторяем до тех пор, пока конец больше начала. Рекурсивно повторяем в зависимости от найденных значений индексов. \